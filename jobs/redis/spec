---
name: redis

templates:
  config/redis.conf.erb: config/redis.conf
  bin/redis_ctl.erb: bin/redis_ctl
  bin/post-start.erb: bin/post-start

packages:
- redis

provides:
- name: redis_conn
  type: conn
  properties:
  - bind
  - port
  - password
  - rename_config_command
  - rename_save_command
  - rename_bgsave_command
  - rename_bgrewriteaof_command
  - rename_monitor_command
  - rename_debug_command
  - rename_shutdown_command
  - rename_slaveof_command
  - rename_replicaof_command
  - rename_sync_command

consumes:
- name: redis_conn
  type: conn
- name: master_conn
  type: conn
- name: slave_conn
  type: conn

properties:
################################## NETWORK #####################################
  bind:
    default: false
    description: |
      Specify this property to "true" if you would like the bind address of a given instance to be automatically set to its assigned static IP. Otherwise, Redis listens only on "localhost".
  port:
    default: "6379"
    description: |
      Accept connections on the specified port, default is 6379 (IANA #815344). If port 0 is specified Redis will not listen on a TCP socket.
  timeout:
    default: "0"
    description: |
      Close the connection after a client is idle for N seconds (0 to disable).
  tcp_keepalive:
    default: "300"
    description: |
      TCP keepalive. If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence of communication. A reasonable value for this option is 300 seconds, which is the new Redis default starting with Redis 3.2.1.
################################# GENERAL #####################################
  run_dir:
    default: "/var/vcap/sys/run/redis"
    description: |
      Directory where to store Redis pid file.
  pidfile:
    default: "redis.pid"
    description: |
      If a pid file is specified, Redis writes it where specified at startup and removes it at exit.
      When the server runs non daemonized, no pid file is created if none is specified in the configuration. When the server is daemonized, the pid file is used even if not specified, defaulting to "/var/run/redis.pid".
      Creating a pid file is best effort: if Redis is not able to create it nothing bad happens, the server will start and run normally.
  loglevel:
    default: "notice"
    description: |
      Specify the server verbosity level.
      This can be one of:
        - "debug" (a lot of information, useful for development/testing),
        - "verbose" (many rarely useful info, but not a mess like the debug level),
        - "notice" (moderately verbose, what you want in production probably),
        - "warning" (only very important / critical messages are logged).
  log_dir:
    default: "/var/vcap/sys/log/redis"
    description: |
      Directory where to store Redis log file.
  logfile:
    default: "redis.log"
    description: |
      Specify the log file name. Also the empty string can be used to force Redis to log on the standard output. Note that if you use standard output for logging but daemonize, logs will be sent to /dev/null.
  syslog_enabled:
    default: "yes"
    description: |
      To enable logging to the system logger, just set syslog-enabled to yes, and optionally update the other syslog parameters to suit your needs.
  syslog_ident:
    default: "redis-server"
    description: |
      Specify the syslog identity.
  syslog_facility:
    default: "local0"
    description: |
      Specify the syslog facility. Must be USER or between LOCAL0-LOCAL7.
  databases:
    default: "16"
    description: |
      Set the number of databases. The default database is DB 0, you can select a different one on a per-connection basis using SELECT <dbid> where dbid is a number between 0 and <databases>-1.
################################ SNAPSHOTTING  ################################
  save:
    default:
      - "900 1"
      - "300 10"
      - "60 10000"
    description: |
      Save the DB on disk:
        save <seconds> <changes>
      Will save the DB if both the given number of seconds and the given number of write operations against the DB occurred.
      In the example below the behaviour will be to save:
        - after 900 sec (15 min) if at least 1 key changed
        - after 300 sec (5 min) if at least 10 keys changed
        - after 60 sec if at least 10000 keys changed
      Note: you can disable saving completely by commenting out all "save" lines.
      It is also possible to remove all the previously configured save points by adding a save directive with a single empty string argument like in the following example:
        save ""
  stop_writes_on_bgsave_error:
    default: "yes"
    description: |
      By default Redis will stop accepting writes if RDB snapshots are enabled (at least one save point) and the latest background save failed. This will make the user aware (in a hard way) that data is not persisting on disk properly, otherwise chances are that no one will notice and some disaster will happen. However if you have setup your proper monitoring of the Redis server and persistence, you may want to disable this feature so that Redis will continue to work as usual even if there are problems with disk, permissions, and so forth.
  rdbcompression:
    default: "yes"
    description: |
      Compress string objects using LZF when dump .rdb databases.
  rdbchecksum:
    default: "yes"
    description: |
      Since version 5 of RDB a CRC64 checksum is placed at the end of the file. This makes the format more resistant to corruption but there is a performance hit to pay (around 10%) when saving and loading RDB files, so you can disable it for maximum performances.
  dir:
    default: "/var/vcap/store/redis"
    description: |
      The working directory. The DB will be written inside this directory. The Append Only File will also be created inside this directory.
################################# REPLICATION #################################
  replication:
    default: false
    description: |
      When set to false, master/slave replication will be disabled and all instances will run as standalone deployments.
  replica_serve_stale_data:
    default: "yes"
    description: |
      When a replica loses its connection with the master, or when the replication is still in progress, the replica can act in two different ways:
        1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
           still reply to client requests, possibly with out of date data, or the
           data set may just be empty if this is the first synchronization.
        2) if replica-serve-stale-data is set to 'no' the replica will reply with
           an error "SYNC with master in progress" to all the kind of commands
           but to INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
           SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB,
           COMMAND, POST, HOST: and LATENCY.
  replica_read_only:
    default: "yes"
    description: |
      You can configure a replica instance to accept writes or not. Writing against a replica instance may be useful to store some ephemeral data (because data written on a replica will be easily deleted after resync with the master) but may also cause problems if clients are writing to it because of a misconfiguration.
      Since Redis 2.6 by default replicas are read-only.
      Note: read only replicas are not designed to be exposed to untrusted clients on the internet. It's just a protection layer against misuse of the instance. Still a read only replica exports by default all the administrative commands such as CONFIG, DEBUG, and so forth. To a limited extent you can improve security of read only replicas using 'rename-command' to shadow all the administrative / dangerous commands.
  repl_ping_replica_period:
    default: "10"
    description: |
      Replicas send PINGs to server in a predefined interval. It is possible to change this interval with the repl_ping_replica_period option. The default value is 10 seconds.
  repl_timeout:
    default: "60"
    description: |
      The following option sets the replication timeout for:
        1) Bulk transfer I/O during SYNC, from the point of view of replica.
        2) Master timeout from the point of view of replicas (data, pings).
        3) Replica timeout from the point of view of masters (REPLCONF ACK pings).
      It is important to make sure that this value is greater than the value specified for repl-ping-replica-period otherwise a timeout will be detected every time there is low traffic between the master and the replica.
  repl_disable_tcp_nodelay:
    default: "no"
    description: |
      Disable TCP_NODELAY on the replica socket after SYNC?
      If you select "yes" Redis will use a smaller number of TCP packets and less bandwidth to send data to replicas. But this can add a delay for the data to appear on the replica side, up to 40 milliseconds with Linux kernels using a default configuration.
      If you select "no" the delay for data to appear on the replica side will be reduced but more bandwidth will be used for replication.
      By default we optimize for low latency, but in very high traffic conditions or when the master and replicas are many hops away, turning this to "yes" may be a good idea.
  replica_priority:
    default: "100"
    description: |
      The replica priority is an integer number published by Redis in the INFO output.
      It is used by Redis Sentinel in order to select a replica to promote into a master if the master is no longer working correctly.
      A replica with a low priority number is considered better for promotion, so for instance if there are three replicas with priority 10, 100, 25 Sentinel will pick the one with priority 10, that is the lowest.
      However a special priority of 0 marks the replica as not able to perform the role of master, so a replica with priority of 0 will never be selected by Redis Sentinel for promotion.
      By default the priority is 100.
  min_replicas_to_write:
    default: "1"
    description: |
      It is possible for a master to stop accepting writes if there are less than N replicas connected, having a lag less or equal than M seconds.
      The N replicas need to be in "online" state.
      The lag in seconds, that must be <= the specified value, is calculated from the last ping received from the replica, that is usually sent every second.
      This option does not GUARANTEE that N replicas will accept the write, but will limit the window of exposure for lost writes in case not enough replicas are available, to the specified number of seconds.
      For example to require at least 3 replicas with a lag <= 10 seconds use:
        min-replicas-to-write 3
        min-replicas-max-lag 10
      Setting one or the other to 0 disables the feature.
      By default min-replicas-to-write is set to 0 (feature disabled) and min-replicas-max-lag is set to 10.
  min_replicas_max_lag:
    default: "10"
    description: |
      See previous "min_replicas_to_write".
  replica_announce:
    default: false
    description: |
      When port forwarding or Network Address Translation (NAT) is used, the replica may be actually reachable via different IP and port pairs. The option can be used by a replica in order to report to its master a specific set of IP and port, so that both INFO and ROLE will report those values.
################################## SECURITY ###################################
  password:
    description: |
      Require clients to issue AUTH <PASSWORD> before processing any other commands.  This might be useful in environments in which you do not trust others with access to the host running redis-server.
      This should stay commented out for backward compatibility and because most people do not need auth (e.g. they run their own servers).
      Warning: since Redis is pretty fast an outside user can try up to 150k passwords per second against a good box. This means that you should use a very strong password otherwise it will be very easy to break.
  rename_config_command:
    description: |
      The name of the obfuscated Redis CONFIG command.
  rename_save_command:
    description: |
      The name of the obfuscated Redis SAVE command.
  rename_bgsave_command:
    description: |
      The name of the obfuscated Redis BGSAVE command.
  rename_bgrewriteaof_command:
    description: |
      The name of the obfuscated Redis BGREWRITEAOF command.
  rename_monitor_command:
    description: |
      The name of the obfuscated Redis MONITOR command.
  rename_debug_command:
    description: |
      The name of the obfuscated Redis DEBUG command.
  rename_shutdown_command:
    description: |
      The name of the obfuscated Redis SHUTDOWN command.
  rename_slaveof_command:
    description: |
      The name of the obfuscated Redis SLAVEOF command.
  rename_replicaof_command:
    description: |
      The name of the obfuscated Redis REPLICAOF command.
  rename_sync_command:
    description: |
      The name of the obfuscated Redis SYNC command.
################################### CLIENTS ####################################
  maxclients:
    default: "10000"
    description: |
      Set the max number of connected clients at the same time. By default this limit is set to 10000 clients, however if the Redis server is not able to configure the process file limit to allow for the specified limit the max number of allowed clients is set to the current file limit minus 32 (as Redis reserves a few file descriptors for internal uses).
      Once the limit is reached Redis will close all the new connections sending an error max number of clients reached."
############################## APPEND ONLY MODE ###############################
  appendonly:
    default: "no"
    description: |
      By default Redis asynchronously dumps the dataset on disk. This mode is good enough in many applications, but an issue with the Redis process or a power outage may result into a few minutes of writes lost (depending on the configured save points).
      The Append Only File is an alternative persistence mode that provides much better durability. For instance using the default data fsync policy (see later in the config file) Redis can lose just one second of writes in a dramatic event like a server power outage, or a single write if something wrong with the Redis process itself happens, but the operating system is still running correctly.
      AOF and RDB persistence can be enabled at the same time without problems.
      If the AOF is enabled on startup Redis will load the AOF, that is the file with the better durability guarantees.
      Please check http://redis.io/topics/persistence for more information.
  appendfsync:
    default: "everysec"
    description: |
      The fsync() call tells the Operating System to actually write data on disk instead of waiting for more data in the output buffer. Some OS will really flush data on disk, some other OS will just try to do it ASAP.
      Redis supports three different modes:
        "no": don't fsync, just let the OS flush the data when it wants. Faster,
        "always": fsync after every write to the append only log. Slow, Safest,
        "everysec": fsync only one time every second. Compromise.
      The default is "everysec", as that's usually the right compromise between speed and data safety. It's up to you to understand if you can relax this to "no" that will let the operating system flush the output buffer when it wants, for better performances (but if you can live with the idea of some data loss consider the default persistence mode that's snapshotting), or on the contrary, use "always" that's very slow but a bit safer than "everysec".
      More details please check the following article:
        http://antirez.com/post/redis-persistence-demystified.html
      If unsure, use "everysec".
################################ LUA SCRIPTING  ###############################
  lua_time_limit:
    default: "5000"
    description: |
      Max execution time of a Lua script in milliseconds.
################################ REDIS CLUSTER  ###############################
  cluster_enabled:
    default: "no"
    description: |
      If "yes" enables Redis Cluster support in a specific Redis instance. Otherwise the instance starts as a stand alone instance as usual.
  cluster_node_timeout:
    default: "15000"
    description: |
      The maximum amount of time a Redis Cluster node can be unavailable, without it being considered as failing. If a master node is not reachable for more than the specified amount of time, it will be failed over by its slaves. This parameter controls other important things in Redis Cluster. Notably, every node that can not reach the majority of master nodes for the specified amount of time, will stop accepting queries.
  cluster_replicas_node_count:
    description: |
      default: "0"
      Number of replicas per cluster's node.
  cluster_replica_validity_factor:
    default: "10"
    description: |
      A replica of a failing master will avoid to start a failover if its data looks too old.
      There is no simple way for a replica to actually have an exact measure of its "data age", so the following two checks are performed:
        1) If there are multiple replicas able to failover, they exchange messages in order to try to give an advantage to the replica with the best replication offset (more data from the master processed). Replicas will try to get their rank by offset, and apply to the start of the failover a delay proportional to their rank.
        2) Every single replica computes the time of the last interaction with its master. This can be the last ping or command received (if the master is still in the "connected" state), or the time that elapsed since the disconnection with the master (if the replication link is currently down). If the last interaction is too old, the replica will not try to failover at all.
      The point "2" can be tuned by user. Specifically a replica will not perform the failover if, since the last interaction with the master, the time elapsed is greater than:
        (node-timeout * replica-validity-factor) + repl-ping-replica-period
      So for example if node-timeout is 30 seconds, and the replica-validity-factor is 10, and assuming a default repl-ping-replica-period of 10 seconds, the replica will not try to failover if it was not able to talk with the master for longer than 310 seconds.
      A large replica-validity-factor may allow replicas with too old data to failover a master, while a too small value may prevent the cluster from being able to elect a replica at all.
      For maximum availability, it is possible to set the replica-validity-factor to a value of 0, which means, that replicas will always try to failover the master regardless of the last time they interacted with the master. (However they'll always try to apply a delay proportional to their offset rank).
      Zero is the only value able to guarantee that when all the partitions heal the cluster will always be able to continue.
  cluster_migration_barrier:
    default: "1"
    description: |
      Cluster replicas are able to migrate to orphaned masters, that are masters that are left without working replicas. This improves the cluster ability to resist to failures as otherwise an orphaned master can't be failed over in case of failure if it has no working replicas.
      Replicas migrate to orphaned masters only if there are still at least a given number of other working replicas for their old master. This number is the "migration barrier". A migration barrier of 1 means that a replica will migrate only if there is at least 1 other working replica for its master and so forth. It usually reflects the number of replicas you want for every master in your cluster.
      Default is 1 (replicas migrate only if their masters remain with at least one replica). To disable migration just set it to a very large value.
      A value of 0 can be set but is useful only for debugging and dangerous in production.
  cluster_require_full_coverage:
    default: "yes"
    description: |
      If this is set to "yes", as it is by default, the cluster stops accepting writes if some percentage of the key space is not covered by any node. If the option is set to no, the cluster will still serve queries even if only requests about a subset of keys can be processed.
  cluster_announce:
    default: false
    description: |
      In certain deployments, Redis Cluster nodes address discovery fails, because addresses are NAT-ted or because ports are forwarded (the typical case is Docker and other containers).
      In order to make Redis Cluster working in such environments, a static configuration where each node knows its public address is needed. The following two options are used for this scope, and are:
        - cluster-announce-ip
        - cluster-announce-port
        - cluster-announce-bus-port
      Each instruct the node about its address, client port, and cluster message bus port. The information is then published in the header of the bus packets so that other nodes will be able to correctly map the address of the node publishing the information.
      If the above options are not used, the normal Redis Cluster auto-detection will be used instead.
      Note that when remapped, the bus port may not be at the fixed offset of clients port + 10000, so you can specify any port and bus-port depending on how they get remapped. If the bus-port is not set, a fixed offset of 10000 will be used as usually.
################################## SLOW LOG ###################################
  slowlog_log_slower_than:
    default: "10000"
    description: |
      The execution time, in microseconds, to exceed in order for the command to get logged. Time is expressed in microseconds, so 1000000 is equivalent to one second. Note that a negative number disables the slow log, while a value of zero forces the logging of every command.
  slowlog_max_len:
    default: "128"
    description: |
      The length of the slow log. There is no limit to this length. Just be aware that it will consume memory. You can reclaim memory used by the slow log with SLOWLOG RESET.
